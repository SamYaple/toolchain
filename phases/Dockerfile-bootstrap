# syntax=docker/dockerfile:1
ARG FROM=docker.io/library/debian:bookworm-slim

FROM ${FROM} as bootstrap
# The buildkit cache used for apt is setup here, and used throughout the
# Dockerfile. The `docker-clean` apt configuration conflicts with this way of
# caching and must be removed. This is the only time `apt-get update`.
COPY debian.sources /etc/apt/sources.list.d/
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    rm /etc/apt/apt.conf.d/docker-clean \
    && apt-get update
# The `triple` also becomes a tag to break from the default and debug option
# propogation. The default triple would be `x86_64-unknown-linux-gnu`
ENV BOOTSTRAP_TRIPLE=x86_64-phiban-linux-gnu
ENV BOOTSTRAP_SYSROOT=/bootstrap

# Create a new sysroot and extract glibc with relevant kernel header files. This
# gets us a minimal glibc sysroot with no c++ support.
WORKDIR ${BOOTSTRAP_SYSROOT}
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get download libc6 libc6-dev linux-libc-dev

# extract a pre-built glibc and headers. this step should work from a non-debian
# based system if you extract the deb files in the same way.
RUN for deb in *.deb; do dpkg-deb -x ${deb} .; done \
    && mv lib/x86_64-linux-gnu/* usr/lib/x86_64-linux-gnu/* usr/lib/ \
    && rm -rf lib lib64 usr/lib/x86_64-linux-gnu *.deb etc/ld.so.conf.d/* \
    && echo "${BOOTSTRAP_SYSROOT}/usr/lib" > etc/ld.so.conf.d/bootstrap-sysroot.conf \
    && mkdir usr/bin \
    && ln -sv bin usr/sbin \
    && ln -sv lib usr/lib64 \
    && ln -sv usr/lib lib \
    && ln -sv usr/lib lib64 \
    && ln -sv usr/bin bin \
    && ln -sv usr/bin sbin \
    && ln -sv . bootstrap \
    && cd lib \
    && find . -type l -exec sh -c 'ln -svf "$1".* "$1"' _ {} \; \
    && ln -sv . x86_64-linux-gnu

# Install a base toolchain to build our bootstrap compiler from. We are using
# `gcc` and `g++` for the C compiler and C++ compiler respectively. You could
# swap out this with any other compiler that can build LLVM, at least in theory.
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install --no-install-recommends -y gcc g++

# These tools are required to build LLVM
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install --no-install-recommends -y cmake python3 ninja-build

# These tools are nice to have, but not strictly required to build LLVM
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install --no-install-recommends -y git ccache

# The ccache data is stored in a buildkit style volume mount. As long as the
# build directory isn't changing, it will cache both stage1 and stage2 builds.
#
# You'll thank me if you ever have a failed build... otherwise this is just
# burning a bit of extra space. `sccache` is used instead of `ccache` in later
# phases as a unified caching tool for rust and clang.
ENV CCACHE_DIR=/ccache
ENV CCACHE_CPP2=yes
ENV CCACHE_HASHDIR=yes

# The cmake file `llvm.cmake` is commented for further reading.
WORKDIR /git_sources/llvm-project
COPY llvm.cmake /
RUN --mount=type=cache,target=${CCACHE_DIR},id=ccache-bootstrap \
    cmake -S llvm -B build -G Ninja \
        -D CMAKE_C_COMPILER_LAUNCHER=ccache \
        -D CMAKE_CXX_COMPILER_LAUNCHER=ccache \
        -D BUILD_SYSROOT="" \
        -D BUILD_TRIPLE=${BOOTSTRAP_TRIPLE} \
        -D TARGET_SYSROOT=${BOOTSTRAP_SYSROOT} \
        -D TARGET_TRIPLE=${BOOTSTRAP_TRIPLE} \
        -D STATIC_CORE=ON \
        -D LLVM_BUILD_LTO=OFF \
        -C /llvm.cmake \
    && cmake --build build --target runtimes \
    && cmake --build build --target install-runtimes \
    && cmake --build build --target stage2-distribution \
    && cmake --build build --target stage2-install-distribution

FROM scratch
COPY --from=bootstrap /bootstrap /bootstrap
