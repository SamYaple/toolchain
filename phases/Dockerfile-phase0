# syntax=docker/dockerfile:1
ARG FROM=docker.io/library/debian:bookworm-slim

FROM ${FROM} AS phase0
COPY debian.sources /etc/apt/sources.list.d/
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    rm /etc/apt/apt.conf.d/docker-clean \
    && apt-get update

# Setup some common variables used throughout the build process, but not in the
# final produced image. No trickery going on here, just some helper vars.
ENV GLIBC_SYSROOT=/sysroots/glibc
ENV GLIBC_TRIPLE=x86_64-phiban-linux-gnu
ENV MUSL_SYSROOT=/sysroots/musl
ENV MUSL_TRIPLE=x86_64-phiban-linux-musl
ENV CARGO_HOME=/cargo
ENV CCACHE_DIR=/ccache
ENV CCACHE_CPP2=yes
ENV CCACHE_HASHDIR=yes
ENV PATH="${GLIBC_SYSROOT}/usr/bin:${PATH}"

# Copy over the /sysroots/glibc that was created in the bootstrap image. This
# sysroot has our target version of clang and llvm, linked against `glibc` and
# `libc++`. No other tooling is installed in the sysroot, it is minimal.
COPY --from=localhost/bootstrap:latest /bootstrap ${GLIBC_SYSROOT}
RUN ln -sv clang ${GLIBC_SYSROOT}/bin/c++ \
    && ln -sv clang ${GLIBC_SYSROOT}/bin/cc

RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install --no-install-recommends -y make

# Setup base filesystem structure
WORKDIR ${MUSL_SYSROOT}
RUN mkdir usr usr/bin usr/lib etc \
    && ln -sv usr/lib lib \
    && ln -sv usr/bin bin \
    && ln -sv . toolchain \
    && ln -sv ${MUSL_SYSROOT} /toolchain

# We need the linux headers to build musl (unlike with glibc). We build them
# using our bootstrap compiler. TODO: detail the what/when/hows of this process
WORKDIR /sources/linux
RUN make HOSTCFLAGS="--sysroot=${GLIBC_SYSROOT}" HOSTLDFLAGS="--sysroot=${GLIBC_SYSROOT}" LLVM=1 -j64 headers \
    && find usr/include -type f ! -name '*.h' -delete \
    && cp -rv usr/include ${MUSL_SYSROOT}/usr/include

# Build and install musl libc using our bootstrap tools. A small twist is having
# `/toolchain/etc/ld-musl-x86_64.path` look into `/toolchain/usr` vs `/usr`.
# This further isolates our new toolchain from any host files.
WORKDIR /sources/musl
RUN ./configure CFLAGS="--sysroot=${GLIBC_SYSROOT}" --prefix="${MUSL_SYSROOT}/usr" \
    && make -j64 \
    && make install \
    && rm -v /lib/ld-musl-x86_64.so.1 \
    && echo "${MUSL_SYSROOT}/usr/lib" > ${MUSL_SYSROOT}/etc/ld-musl-x86_64.path \
    && ln -svf libc.so ${MUSL_SYSROOT}/usr/lib/ld-musl-x86_64.so.1 \
    && ln -svf ../lib/libc.so ${MUSL_SYSROOT}/usr/bin/ldd

# We do not use the packaged make again, we build it next time it is needed
RUN apt-get autoremove --purge -y make

# We use the following utils for building LLVM
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install --no-install-recommends -y cmake python3 ninja-build patch ccache

WORKDIR /sources/llvm-project
COPY llvm.cmake /
COPY patches/llvm-project /patches/llvm-project
RUN --mount=type=cache,target=${CCACHE_DIR},id=ccache-phase0 \
    patch -p1 < /patches/llvm-project/toolchain-prefix.patch \
    && cmake -S llvm -B build -G Ninja \
        -D CMAKE_C_COMPILER_LAUNCHER=ccache \
        -D CMAKE_CXX_COMPILER_LAUNCHER=ccache \
        -D BUILD_SYSROOT=${GLIBC_SYSROOT} \
        -D BUILD_TRIPLE=${GLIBC_TRIPLE} \
        -D TARGET_SYSROOT=${MUSL_SYSROOT} \
        -D TARGET_TRIPLE=${MUSL_TRIPLE} \
        -D STATIC_CORE=ON \
        -D LLVM_BUILD_LTO=OFF \
        -C /llvm.cmake \
    && cmake --build build --target runtimes \
    && cmake --build build --target install-runtimes \
    && cmake --build build --target stage2-distribution \
    && cmake --build build --target stage2-install-distribution

# We no longer use anything glibc in the build; trash it!
RUN apt-get autoremove --purge -y cmake python3 ninja-build ccache
RUN rm -rf ${GLIBC_SYSROOT}

ENV PATH="${MUSL_SYSROOT}/usr/bin:${PATH}"
ENV CFLAGS="--sysroot=${MUSL_SYSROOT}"
ENV CXXFLAGS="--sysroot=${MUSL_SYSROOT}"
ENV LDFLAGS="--sysroot=${MUSL_SYSROOT}"

RUN ln -sv lld ${MUSL_SYSROOT}/bin/ld

# Bootstrap GNU `make`, using the `./build.sh` bootstrap script
WORKDIR /sources/make
COPY patches/make /patches/make
RUN patch -p1 < /patches/make/fix-bootstrap.patch \
    && ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && ./build.sh \
    && ./make install

# Remove the last of the host distro packages
RUN apt-get autoremove --purge -y patch

WORKDIR /sources/patch
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && make -j64 \
    && make install

# rust bootstrap needs to extract tar.gz archives from pythons tarfile
# perl wants system zlib
# openssl wants system zlib
WORKDIR /sources/zlib
COPY patches/zlib /patches/zlib
RUN patch -p1 < /patches/zlib/hack-fix-failed-shared-build.patch \
    && ./configure --prefix=${MUSL_SYSROOT}/usr \
    && make -j64 \
    && make install \
    && rm -fv ${MUSL_SYSROOT}/usr/lib/libz.a

# perl wants system bzip2
WORKDIR /sources/bzip2
RUN sed -i -e 's@CC=gcc@CC=clang@' -e 's@\(ln -s -f \)$(PREFIX)/bin/@\1@' Makefile* \
    && make -f Makefile-libbz2_so \
    && make clean \
    && make -j64 \
    && make PREFIX=${MUSL_SYSROOT}/usr install \
    && cp -av bzip2-shared ${MUSL_SYSROOT}/usr/bin/bzip2 \
    && cp -av libbz2.so.* ${MUSL_SYSROOT}/usr/lib \
    && ln -sv libbz2.so.1.0.8 ${MUSL_SYSROOT}/usr/lib/libbz2.so \
    && ln -sfv bzip2 ${MUSL_SYSROOT}/usr/bin/bzcat \
    && ln -sfv bzip2 ${MUSL_SYSROOT}/usr/bin/bunzip2 \
    && rm -fv ${MUSL_SYSROOT}/usr/lib/libbz2.a

# openssl needs perl
WORKDIR /sources/perl
RUN export BUILD_ZLIB=False BUILD_BZIP2=0 \
    && sh Configure -des \
        -D libc=__REPLACE_LIBDIR__/libc.so \
        -D prefix=__REPLACE_PREFIX__ \
        -D vendorprefix=__REPLACE_PREFIX__ \
        -D bin=__REPLACE_PREFIX__/bin \
        -D vendorbin=__REPLACE_PREFIX__/bin \
        -D vendorscript=__REPLACE_PREFIX__/bin \
        -D privlib=__REPLACE_LIBDIR__/perl5/5.40/core_perl \
        -D archlib=__REPLACE_LIBDIR__/perl5/5.40/core_perl \
        -D sitelib=__REPLACE_LIBDIR__/perl5/5.40/site_perl \
        -D sitearch=__REPLACE_LIBDIR__/perl5/5.40/site_perl \
        -D vendorlib=__REPLACE_LIBDIR__/perl5/5.40/vendor_perl \
        -D vendorarch=__REPLACE_LIBDIR__/perl5/5.40/vendor_perl \
        -D userelocatableinc \
        -D useshrplib \
        -D usethreads \
    && sed -i \
           -e 's|__REPLACE_PREFIX__|'${MUSL_SYSROOT}'/usr|g' \
           -e 's|__REPLACE_LIBDIR__|'${MUSL_SYSROOT}'/usr/lib|g' \
           Makefile \
    && sed -i \
           -e '/^[^=]*install[^=]*=/ s|__REPLACE_PREFIX__|'${MUSL_SYSROOT}'/usr|g' \
           -e '/^[^=]*install[^=]*=/ s|__REPLACE_LIBDIR__|'${MUSL_SYSROOT}'/usr/lib|g' \
           Policy.sh \
           config.sh \
    && sed -i \
           -e 's|__REPLACE_PREFIX__|.../..|g' \
           -e 's|__REPLACE_LIBDIR__|.../../lib|g' \
           config.sh \
           Policy.sh \
    && make -j64 \
    && make install

# cargo needs openssl-sys
# cmake wants openssl
WORKDIR /sources/openssl
RUN CC=cc CXX=cxx ${MUSL_SYSROOT}/usr/bin/perl ./Configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --openssldir=${MUSL_SYSROOT}/etc/ssl \
        --libdir=lib \
        shared \
        zlib-dynamic \
    && make -j64 \
    && make install_sw

# rust bootstrap uses python
WORKDIR /sources/python
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
        --without-ensurepip \
        --enable-shared \
    && make -j64 \
    && make install

# cargo dependency openssl-sys needs pkg-config
WORKDIR /sources/pkgconf
RUN ./configure --prefix=${MUSL_SYSROOT}/usr --disable-static \
    && make -j64 \
    && make install
RUN ln -sv pkgconf ${MUSL_SYSROOT}/usr/bin/pkg-config

# rust bootstrapping needs this (because of the target json?)
WORKDIR /sources/cmake
RUN ./bootstrap --parallel=64 -- \
        -D CMAKE_INSTALL_PREFIX=${MUSL_SYSROOT}/usr \
    && make -j64 \
    && make install

WORKDIR /sources/ninja
RUN cmake \
        -B build \
        -D CMAKE_INSTALL_PREFIX=${MUSL_SYSROOT}/usr \
        -D BUILD_TESTING=OFF \
    && cmake --build build --parallel 64 \
    && cmake --build build --target install

#### RUST BOOTSTRAPPING start
ENV RUSTBOOTSTRAP=/rustbootstrap
RUN mkdir ${RUSTBOOTSTRAP}

# the stage0 compiler downloaded is linked against `libgcc_s` which we do not
# have. We can build a compat layer manually. We remove this after building
# rust the first time.
WORKDIR /git_sources/llvm-project/llvm-libgcc
RUN clang -E -xc gcc_s.ver.in -o gcc_s.ver \
    && clang --sysroot=${MUSL_SYSROOT} -nostdlib \
        -Wl,--version-script,gcc_s.ver \
        -Wl,--whole-archive \
        ${MUSL_SYSROOT}/usr/lib/clang/19/lib/${MUSL_TRIPLE}/libclang_rt.builtins.a \
        ${MUSL_SYSROOT}/usr/lib/libunwind.a \
        -Wl,-soname,libgcc_s.so.1.0 \
        -lc -shared -o libgcc_s.so.1.0 \
    && install -m 0644 ./libgcc_s.so.1.0 ${MUSL_SYSROOT}/usr/lib/libgcc_s.so.1.0 \
    && ln -sv libgcc_s.so.1.0 ${MUSL_SYSROOT}/usr/lib/libgcc_s.so.1 \
    && ln -sv libgcc_s.so.1   ${MUSL_SYSROOT}/usr/lib/libgcc_s.so \
    && ln -sv ${MUSL_SYSROOT}/lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1 \
    && ln -sv ${MUSL_SYSROOT}/etc/ld-musl-x86_64.path /etc/ld-musl-x86_64.path

# FIXME: curl gets installed for the inital rustc bootstrap
# TODO: cache these deps so rust bootstrap doesnt need curl
RUN --mount=type=cache,target=/var/cache/apt,id=apt \
    apt-get install -y curl

WORKDIR /sources/rustc
COPY x86_64-phiban-linux-musl.json /
COPY patches/rust /patches/rust
RUN --mount=type=cache,target=/rustbootstrapdeps,id=rust-bootstrap-cache \
    patch -p1 < /patches/rust/dynamic-musl-target.patch \
    && ./configure \
        --tools=cargo,clippy,rustfmt \
        --set=build.bootstrap-cache-path=/rustbootstrapdeps \
        --set=build.jobs=64 \
        --set=build.docs=false \
        --set=build.host=${MUSL_TRIPLE} \
        --set=build.build=x86_64-unknown-linux-musl \
        --set=build.target=/${MUSL_TRIPLE}.json \
        --set=install.prefix=${RUSTBOOTSTRAP} \
        --set=install.sysconfdir=etc \
        --set=llvm.use-libcxx=true \
        --set=rust.llvm-libunwind=system \
        --set=rust.musl-root=${MUSL_SYSROOT}/usr \
        --set=target.${MUSL_TRIPLE}.crt-static=false \
        --set=target.${MUSL_TRIPLE}.llvm-config=${MUSL_SYSROOT}/usr/bin/llvm-config \
        --set=target.x86_64-unknown-linux-musl.crt-static=false \
        --set=target.x86_64-unknown-linux-musl.llvm-config=${MUSL_SYSROOT}/usr/bin/llvm-config \
    && ./x.py build -j64 \
    && ./x.py install

# HACK: Cleanup all our hacked in files. Everything should be linked correctly
#       against libunwind and `/toolchain` now. `libgcc_s` and `curl` are no
#       longer needed.
RUN apt-get autoremove --purge -y curl
RUN rm -v ${MUSL_SYSROOT}/usr/lib/libgcc_s.so.1.0 \
          ${MUSL_SYSROOT}/usr/lib/libgcc_s.so.1 \
          ${MUSL_SYSROOT}/usr/lib/libgcc_s.so \
          /lib/ld-musl-x86_64.so.1 \
          /etc/ld-musl-x86_64.path
#### RUST BOOTSTRAPPING end

# HACK this is a nasty thing that needs to be called out. It changes the default
# musl target to be dynamically linked. Traditionally the rust target named
# `x86_64-unknown-linux-musl` would be statically linked, but we want dylib
# stuff. I could do a custom target, but then the names won't match for other
# tools. Given how this distro is being built up, this is a compromise for
# internal consistency vs consistency in the rust ecosystem.
#
# Notice the removed options compared to the first build. No listed option is
# needed anymore. The default musl target is identical in spec to the gnu target
# with only the env name changed to `musl` instead of `gnu`.
#   --set=rust.musl-root=${MUSL_SYSROOT}/usr
#   --set=target.${MUSL_TRIPLE}.crt-static=false
#   --set=build.bootstrap-cache-path=/rustbootstrapdeps
#
# Build rust again with the patched musl-dynamic target
WORKDIR /sources/rustc
COPY patches/rust /patches/rust
RUN patch -p1 < /patches/rust/dynamic-musl-target.patch \
    && ./configure \
        --set=build.jobs=64 \
        --set=build.docs=false \
        --set=build.cargo=${RUSTBOOTSTRAP}/bin/cargo \
        --set=build.cargo-clippy=${RUSTBOOTSTRAP}/bin/cargo-clippy \
        --set=build.rustc=${RUSTBOOTSTRAP}/bin/rustc \
        --set=build.rustfmt=${RUSTBOOTSTRAP}/bin/rustfmt \
        --set=build.host=${MUSL_TRIPLE} \
        --set=build.build=${MUSL_TRIPLE} \
        --set=build.target=${MUSL_TRIPLE} \
        --set=install.prefix=${MUSL_SYSROOT}/usr \
        --set=install.sysconfdir=etc \
        --set=llvm.use-libcxx=true \
        --set=rust.llvm-libunwind=system \
        --set=target.${MUSL_TRIPLE}.llvm-config=${MUSL_SYSROOT}/usr/bin/llvm-config \
    && ./x.py build -j64 \
    && ./x.py install

RUN rm -rfv ${RUST_BOOTSTRAP}

###
# GNU tools
WORKDIR /sources/make
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && make -j64 \
    && make install

WORKDIR /sources/gawk
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
        --disable-extensions \
    && make -j64 \
    && make install

WORKDIR /sources/grep
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && make -j64 \
    && make install

WORKDIR /sources/sed
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && make -j64 \
    && make install

# TODO: Drop this once all sources exist in the git mirror. Use git apply after
WORKDIR /sources/patch
RUN ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
    && make -j64 \
    && make install

# We need a shell. It is not optional if we want to keep building in a container
WORKDIR /sources/bash
COPY patches/bash /patches/bash
RUN patch -p1 < /patches/bash/fix-missing-header.patch && \
    ./configure \
        --prefix=${MUSL_SYSROOT}/usr \
        --build=${MUSL_TRIPLE} \
        --host=${MUSL_TRIPLE} \
        --without-bash-malloc \
    && make -j64 \
    && make install
RUN ln -sv bash ${MUSL_SYSROOT}/usr/bin/sh
# End GNU tools
###

# Steal the ca-certs from curl image so `cargo` will fetch properly.
# TODO: plugin the CA cert for the local git mirror
COPY --from=docker.io/curlimages/curl:latest /etc/ssl /etc/ssl

WORKDIR /git_sources/sccache
RUN --mount=type=cache,target=${CARGO_HOME},id=cargo \
    cargo install --root ${MUSL_SYSROOT}/usr --path ./ --features native-zlib

ENV RUSTC_WRAPPER=sccache
ENV SCCACHE_DIR=/sccache

WORKDIR /git_sources/diffutils
RUN --mount=type=cache,target=${CARGO_HOME},id=cargo \
    --mount=type=cache,target=${SCCACHE_DIR},id=sccache-phase0 \
    cargo install --root ${MUSL_SYSROOT}/usr --path ./

WORKDIR /git_sources/findutils
RUN --mount=type=cache,target=${CARGO_HOME},id=cargo \
    --mount=type=cache,target=${SCCACHE_DIR},id=sccache-phase0 \
    cargo install --root ${MUSL_SYSROOT}/usr --path ./

WORKDIR /git_sources/coreutils
RUN --mount=type=cache,target=${CARGO_HOME},id=cargo \
    --mount=type=cache,target=${SCCACHE_DIR},id=sccache-phase0 \
    cargo install --root ${MUSL_SYSROOT}/usr --path ./ --features unix

# Setup symlinks to ALL THE THINGS (or some of them... honestly there are a lot)
RUN coreutils ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/ln \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/basename \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/cat \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/chmod \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/comm \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/cp \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/cut \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/date \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/dirname \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/echo \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/env \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/expr \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/head \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/ls \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/mkdir \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/mv \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/pwd \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/rm \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/rmdir \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/sleep \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/sort \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/split \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/tee \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/test \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/touch \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/tr \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/true \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/uname \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/uniq \
    && ln -sv coreutils ${MUSL_SYSROOT}/usr/bin/wc \
    && ln -sv diffutils ${MUSL_SYSROOT}/usr/bin/cmp

# When building with Docker/Podman the `RUN` statements are executed with
# `/bin/sh -c 'somecommand -with args'`. We need a symlink setup in the root
# `/bin/sh` -> `/toolchain/bin/sh`. We need to setup the appropriate symlinks
# and then `COPY` them into the container before `RUN` will work. We use the
# busybox image because it is tiny, but any image with `mkdir` and `ln` will
# work for this building this compat layer.
#
# /compat/hack/toolchain -> /sysroots/musl
# /compat/bin/sh         -> /sysroots/musl/usr/bin/sh
# /compat/tmp/
#
# TODO: patch mktemp to use /toolchain/tmp
RUN mkdir -p /compat/hack /compat/bin /compat/tmp \
    && ln -sv /sysroots/musl /compat/hack/toolchain \
    && ln -sv /sysroots/musl/usr/bin/sh /compat/bin/sh

FROM scratch
COPY --from=phase0 /sysroots/musl /sysroots/musl
COPY --from=phase0 /compat/tmp /tmp
COPY --from=phase0 /compat/bin /bin
COPY --from=phase0 /compat/hack/ /
